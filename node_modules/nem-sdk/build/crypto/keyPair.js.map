{"version":3,"sources":["../../src/crypto/keyPair.js"],"names":["BinaryKey","keyData","data","toString","convert","ua2hex","hashfunc","dest","dataLength","convertedData","ua2words","hash","CryptoJS","SHA3","outputLength","words2ua","hashobj","sha3","algo","create","reset","update","converted","length","result","enc","Hex","stringify","Uint8Array","parse","Error","finalize","KeyPair","privkey","publicKey","nacl","lowlevel","crypto_sign_PUBLICKEYBYTES","secretKey","hex2ua_reversed","crypto_sign_keypair_hash","sign","sig","hasher","r","crypto_sign_hash","alert","hexdata","Helpers","isPrivateKeyValid","verifySignature","signature","isPublicKeyValid","isHexadecimal","_pk","hex2ua","_signature","c","p","gf","q","unpackneg","h","subarray","reduce","scalarmult","t","scalarbase","add","pack","crypto_verify_32","module","exports"],"mappings":"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","file":"keyPair.js","sourcesContent":["import nacl from '../external/nacl-fast';\nimport convert from '../utils/convert';\nimport Helpers from '../utils/helpers';\nimport CryptoJS from 'crypto-js';\n\n/***\n* Create a BinaryKey object\n*\n* @param {Uint8Array} keyData - A key data\n*/\nlet BinaryKey = function(keyData) {\n    this.data = keyData;\n    this.toString = function() {\n        return convert.ua2hex(this.data);\n    }\n}\n\nlet hashfunc = function(dest, data, dataLength) {\n    let convertedData = convert.ua2words(data, dataLength);\n    let hash = CryptoJS.SHA3(convertedData, {\n        outputLength: 512\n    });\n    convert.words2ua(dest, hash);\n}\n\n/***\n* Create an hasher object\n*/\nlet hashobj = function() {\n    this.sha3 = CryptoJS.algo.SHA3.create({\n        outputLength: 512\n    });\n    this.reset = function() {\n        this.sha3 = CryptoJS.algo.SHA3.create({\n            outputLength: 512\n        });\n    }\n\n    this.update = function(data) {\n        if (data instanceof BinaryKey) {\n            let converted = convert.ua2words(data.data, data.data.length);\n            let result = CryptoJS.enc.Hex.stringify(converted);\n            this.sha3.update(converted);\n\n        } else if (data instanceof Uint8Array) {\n            let converted = convert.ua2words(data, data.length);\n            this.sha3.update(converted);\n\n        } else if (typeof data === \"string\") {\n            let converted = CryptoJS.enc.Hex.parse(data);\n            this.sha3.update(converted);\n\n        } else {\n            throw new Error(\"unhandled argument\");\n        }\n    }\n\n    this.finalize = function(result) {\n        let hash = this.sha3.finalize();\n        convert.words2ua(result, hash);\n    };\n}\n\n/***\n* Create a KeyPair Object \n*\n* @param {string} privkey - An hex private key\n*/\nlet KeyPair = function(privkey) {\n    this.publicKey = new BinaryKey(new Uint8Array(nacl.lowlevel.crypto_sign_PUBLICKEYBYTES));\n    this.secretKey = convert.hex2ua_reversed(privkey);\n    nacl.lowlevel.crypto_sign_keypair_hash(this.publicKey.data, this.secretKey, hashfunc);\n\n    // Signature\n    this.sign = (data) => {\n        let sig = new Uint8Array(64);\n        let hasher = new hashobj();\n        let r = nacl.lowlevel.crypto_sign_hash(sig, this, data, hasher);\n        if (!r) {\n            alert(\"Couldn't sign the tx, generated invalid signature\");\n            throw new Error(\"Couldn't sign the tx, generated invalid signature\");\n        }\n        return new BinaryKey(sig);\n    }\n}\n\n/**\n* Create a NEM KeyPair\n*\n* @param {string} hexdata - An hex private key\n*\n* @return {object} - The NEM KeyPair object\n*/\nlet create = function(hexdata) {\n    // Errors\n    if(!hexdata) throw new Error('Missing argument !');\n    if (!Helpers.isPrivateKeyValid(hexdata)) throw new Error('Private key is not valid !');\n    // Processing\n    let r = new KeyPair(hexdata);\n    // Result\n    return r;\n}\n\n/**\n * Verify a signature.\n *\n * @param {string} publicKey - The public key to use for verification.\n * @param {string} data - The data to verify.\n * @param {string} signature - The signature to verify.\n *\n * @return {boolean}  - True if the signature is valid, false otherwise.\n */\nlet verifySignature = function(publicKey, data, signature) {\n    // Errors\n    if(!publicKey || !data || !signature) throw new Error('Missing argument !');\n    if (!Helpers.isPublicKeyValid(publicKey)) throw new Error('Public key is not valid !');\n    \n    if (!Helpers.isHexadecimal(signature)) {\n        //console.error('Signature must be hexadecimal only !');\n        return false;\n    }\n    if (signature.length !== 128) {\n        //console.error('Signature length is incorrect !') \n        return false;\n    }\n\n    // Create an hasher object\n    let hasher = new hashobj();\n    // Convert public key to Uint8Array\n    let _pk = convert.hex2ua(publicKey);\n    // Convert signature to Uint8Array\n    let _signature = convert.hex2ua(signature);\n\n    const c = nacl;\n    const p = [c.gf(), c.gf(), c.gf(), c.gf()];\n    const q = [c.gf(), c.gf(), c.gf(), c.gf()];\n\n    if (c.unpackneg(q, _pk)) return false;\n\n    const h = new Uint8Array(64);\n    hasher.reset();\n    hasher.update(_signature.subarray(0, 64/2));\n    hasher.update(_pk);\n    hasher.update(data);\n    hasher.finalize(h);\n\n    c.reduce(h);\n    c.scalarmult(p, q, h);\n\n    const t = new Uint8Array(64);\n    c.scalarbase(q, _signature.subarray(64/2));\n    c.add(p, q);\n    c.pack(t, p);\n\n    return 0 === nacl.lowlevel.crypto_verify_32(_signature, 0, t, 0);\n}\n\nmodule.exports = {\n    create,\n    verifySignature\n}\n"]}